\capitulo{5}{Aspectos relevantes del desarrollo del proyecto}

%Este apartado pretende recoger los aspectos más interesantes del desarrollo del proyecto, comentados por los autores del mismo.
%Debe incluir desde la exposición del ciclo de vida utilizado, hasta los detalles de mayor relevancia de las fases de análisis, diseño e implementación.
%Se busca que no sea una mera operación de copiar y pegar diagramas y extractos del código fuente, sino que realmente se justifiquen los caminos de solución que se han tomado, especialmente aquellos que no sean triviales.
%Puede ser el lugar más adecuado para documentar los aspectos más interesantes del diseño y de la implementación, con un mayor hincapié en aspectos tales como el tipo de arquitectura elegido, los índices de las tablas de la base de datos, normalización y desnormalización, distribución en ficheros3, reglas de negocio dentro de las bases de datos (EDVHV GH GDWRV DFWLYDV), aspectos de desarrollo relacionados con el WWW...
%Este apartado, debe convertirse en el resumen de la experiencia práctica del proyecto, y por sí mismo justifica que la memoria se convierta en un documento útil, fuente de referencia para los autores, los tutores y futuros alumnos.

%Despliegue continuo - direccion de app en heroku. Sistema gratuito sirve para validar, pero no para explotar
%Diseño extensible
%Framework vaadin
%No responsive

En este capítulo se recogen los aspectos más interesantes del desarrollo del proyecto y se justifican las diferentes decisiones tomadas durante el mismo. Se hace mención al motivo de elección del proyecto, el modelo del ciclo de vida empleado, el flujo de trabajo y la configuración del proyecto.


\section{Selección del proyecto}

La elección de este proyecto se debe a su temática de análisis de repositorios. Trata un aspecto al que normalmente no se presta demasiada atención en el desarrollo de proyectos software. Según la experiencia laboral del alumno, normalmente se presta más atención a métricas de proyecto y se descuidan las del proceso, olvidando cuidar la administración de la calidad correctamente.
Esto es un error ya que analizando los repositorios con los que trabajamos en el desarrollo de proyectos podemos obtener métricas que nos dan información muy valiosa. Con esta información podemos detectar problemas que antes pasaban desapercibidos y mejorar en mucho la productividad de los equipos modificando ciertos aspectos del proceso de desarrollo.
En este proyecto se han utilizado métricas que permiten llevar un control sobre el ciclo de vida de uno o varios proyecto, haciendo posible comparar su evolución a lo largo del tiempo. Además, permiten comparar si se están cumpliendo los objetivos definidos y como se mencionaba anteriormente mejorar el proceso de desarrollo aumentando su calidad.

En cuanto a la relación del proyecto con las diferentes asignaturas del Grado, está principalmente relacionado con la asignatura \textit{Desarrollo Avanzado de Sistemas Software}, donde se trata como desarrollar software de calidad mediante el proceso de \textit{Administración de la calidad}, en el cual una de las actividades es el control de calidad. Este control se puede llevar a cabo mediante un proceso de medición utilizando diferentes métricas.


Otras asignaturas relacionadas: 
\begin{itemize}
	\tightlist
	\item \textit{Metodología de la Programación} y \textit{Estructuras de Datos} han contribuido en cuanto a la construcción de una aplicación en un lenguaje Orientado a Objetos.	
		\item \textit{Ingeniería del Software}: ciclo de vida del software, el análisis de los requisitos y el modelado del sistema (diagramas de clases, diagramas de casos de uso, etc).
		\item \textit{Análisis y Diseño de Sistemas}: comprensión del sistema desarrollado en la aplicación Web ya existente \cite{TFGPrevio} de forma que se puedan realizar nuevas implementaciones y mejoras.
	\item \textit{Estadística}: comprensión del cálculo de cuartiles para calcular los valores umbrales de las métricas.
	\item \textit{Interacción Hombre/Máquina}: comprensión de los aspectos fundamentales para mejorar la usabilidad, simplicidad, adaptabilidad de la interfaz gráfica.
	\item \textit{Diseño y Mantenimiento del Software}, el uso de patrones de diseño para mejorar la calidad de código y mantener los principios SOLID  \footnote{Single responsability, Open/Closed, Liskov substitution, Interface segregation, Dependency inversion} y de \textit{Desarrollo Avanzado de Sistemas Software} la naturaleza del trabajo, las revisiones automáticas de calidad de código por medio de métricas y la importancia de la refactorización al detectar defectos de diseño.
	\item \textit{Validación y Pruebas} comprensión de las pruebas ya desarrolladas y construcción de nuevas.
	\item \textit{Sistemas Distribuidos} ha ayudado en el uso de Maven y en la construcción de una aplicación Web.
	\item \textit{Gestión de Proyectos}: ciclo de vida de desarrollo empleado durante el proyecto: \textit{Scrum}\cite{scrum_master_scrum_2019}.
\end{itemize}

\newpage

\section{Modelo de ciclo de vida}
La metodología utilizada durante el desarrollo del proyecto ha sido \textit{\textbf{Scrum}}, realizándose un proceso incremental, dividido en \textit{sprints} de dos semanas. A la finalización de cada \textit{sprint} se ha realizado una reunión denominada \textit{sprint review} que que se compone de dos partes:
\begin{description}
	\item [Revisión del sprint:] o \textit{sprint review}, donde se comentan los avances realizados así como los diferentes problemas que han surgido durante las dos semanas de duración del \textit{sprint}.
Se modifica la pila de desarrollo (\textit{sprint backlog}) pasando a completadas aquellas historias de usuario finalizadas y al siguiente \textit{sprint} las no finalizadas, comentando posibles mejoras y soluciones a los problemas que se hayan tenido \cite{scrum_master_scrum_2019}.

	\item [Planificación del siguiente sprint:] o \textit{sprint planning}, donde e definen las tareasa abordar  durante el siguiente sprint. Estas tareas se recogen del \textit{product backlog} o pila de producto y se añaden a la pila del sprint o \textit{sprint backlog}.
\end{description}

	Concretamente, se ha utilizado \textbf{ZenHub} en conjunto a las \textit{issues} de GitHub para la gestión del proceso \textit{Scrum} en el proyecto.

A lo largo del desarrollo del proyecto, los \textit{sprints} se han centrado en diferentes tareas como pueden ser:
\begin{itemize}
	\item  Tareas de \textbf{investigación}, tanto de las materias relacionadas con el proyecto como de las herramientas que se utilizarán durante el proceso y de \textbf{configuración} del entorno de desarrollo.
	\item En la segunda etapa se aprecian tareas de \textbf{diseño e implementación} de la parte lógica de la aplicación. Se diseña el framework de conexión a forjas de repositorios, se implementa el framework descrito en \textit{Soporte de Métricas con Independencia del Lenguaje para la Inferencia de Refactorizaciones}  \cite{marticorena_sanchez_soporte_2005} para el cálculo de métricas y se diseñan los modelos de datos que serán utilizados por la aplicación.
	\item Tareas de \textbf{desarrollo} de las nuevas funcionalidades del proyecto, como la integración con GitHub, utilizando como base el framework descrito en \textit{Soporte de Métricas con Independencia del Lenguaje para la Inferencia de Refactorizaciones}  \cite{marticorena_sanchez_soporte_2005} y la integración ya existente con GitLab. Nuevos tests y mejoras de diferentes interfaces.
	\item Tareas de \textbf{integración y despliegue continuo} (CI/CD), configurando GitHub Actions y el resto de herramientas para el flujo de trabajo de los sprints.
	\item Revisión de las \textbf{pruebas unitarias} existentes y creación de nuevas con JUnit. automatizando su ejecución gracias a Maven y los \textit{pipelines} \footnote{Definen las actividades de los procesos de CI/CD y las fases y el entorno en las que se ejecutarán} de GitHub Actions.
		\item Configurar \textbf{revisiones automáticas de calidad} y de cobertura de las pruebas gracias a Maven, Codacy, JaCoCo y GitHub.
	\item Configuración y puesta a punto de un entorno en Heroku donde realizar el \textbf{despliegue} la aplicación durante las tareas de de CI/CD.
	\item Revisión y configuración de \textbf{badges} \footnote{Distintivos que aportan información rápida sobre el estado del proyecto en ciertos aspectos como la cobertura, la calidad de código o el proceso de CI/CD y enlazan con la fuente de información} para representar el estado del proyecto en cuanto a calidad de código, cobertura, despliegue y los trabajos de CI/CD.
	\item Implementación de mejoras y nuevos aspectos relacionados con la nueva funcionalidad en la \textbf{interfaz gráfica}.
	\item Tareas de \textbf{documentación} en la que se trabaja sobre la memoria y los anexos.
\end{itemize}

Consultando el \textit{Anexo A - Plan de Proyecto Software} se puede obtener más información sobre los \textit{sprints} realizados y el ciclo de vida del proyecto.

\section{Gestión del proyecto}

En esta sección se explican los diferentes aspectos relacionados con la gestión y configuración del proyecto.

\subsection{Aplicación Web}

Se trabaja sobre la aplicación web implementada en la primera iteración del proyecto\cite{TFGPrevio}.
Un aplicación web tiene como ventajas: 
\begin{itemize}
	\tightlist
	\item El usuario puede acceder a ella directamente desde el navegador, sin necesidad de realizar instalación.
	\item  Al no necesitar instalación, se puede utilizar desde cualquier dispositivo que tenga instalado algún navegador Web. Se ha comprobado la compatibilidad de la aplicación con los siguientes: \textit{Mozilla Firefox}, \textit{Microsoft Edge}, \textit{Internet Explorer}, \textit{Google Chrome} y \textit{Opera}.
	\item Actualizaciones. Para actualizar una aplicación Web, el usuario final no tiene que instalar la actualización. Sino que habrá un periodo de mantenimiento de aplicación, normalmente muy corto y fuera de horario de uso, en el que ningún usuario podrá acceder a la aplicación. Después de este periodo, todos los usuarios dispondrán de la actualización.
	\item En cuanto a la actualización de la aplicación web, los usuarios finales obtendrán la nueva versión en cuanto vuelvan a a acceder a la misma. Para evitar problemas de cacheo en el navegador se suele trabajar con \textit{Service Workers} que permiten la actualización de la web incluso cuando el usuario la está usando.
\end{itemize}


\subsection{Logo de la aplicación}

\begin{figure}[!h]
	\centering
	\includegraphics[width=0.5\textwidth]{_LOGOAPP}
	\caption{Logo de Evolution Metrics Gauge}\label{fig:_LOGOAPP}
\end{figure}
\FloatBarrier

En la Fig. \ref{fig:_LOGOAPP} se muestra el logo de la aplicación que se ha mantenido al tratarse este proyecto de una nueva iteración. Éste se compone de un tacómetro que simboliza la medición y un gráfico \textit{burndown} que simboliza la evolución de un proyecto. Lo que se pretende es mostrar la funcionalidad principal de la aplicación: calcular métricas de evolución.


\subsection{Java 11}
Se ha mantenido la versión utilizada en el proyecto original\cite{TFGPrevio}, Java 11.
Para esta versión, la configuración necesaria de Maven para que el proyecto compile es la siguiente \ruta{pom.xml}:

%Tomcat \footnote{Para desplegar aplicaciones con Java 11 se requiere de la versión 9.0.x de Tomcat} y 
% del proyecto para que Maven compile en la versión 11 de Java:

\begin{minipage}{\linewidth}
{\tiny
\begin{verbatim}
...
<properties>
	<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
	<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
	<java.version>11</java.version>
</properties>
...
<build>
...
	<plugins>
		<plugin>
			<groupId>org.apache.maven.plugins</groupId>
			<artifactId>maven-compiler-plugin</artifactId>
			<configuration>
				<source>${java.version}</source>
				<target>${java.version}</target>
			</configuration>
			<version>3.8.1</version>
		</plugin>
		<plugin>
			<groupId>org.apache.maven.plugins</groupId>
			<artifactId>maven-war-plugin</artifactId>
			<version>3.2.2</version>
		</plugin>
		...
	</plugins>
	...
</build>
...
\end{verbatim}
}
\end{minipage}

\newpage
Y en Eclipse IDE habría que añadir manualmente el JRE desde la ventana Window/Preferences, como se muestra en la siguiente figura: 

\begin{figure}[!h]
	\centering
	\includegraphics[width=0.7\textwidth]{M5_Eclipse_Java11}
	\caption{JRE empleado en la aplicación}\label{fig:M5_Eclipse_Java11}
\end{figure}
\FloatBarrier



%De la utilización de Java 11 destacan dos aspectos ya existentes en el proyecto:          
%	\item De la versión 11 se ha utilizado el método \textit{isBlank()} de la clase \textit{String} \footnote{\url{https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html}}. Se diferencia de \textit{isEmpty()} en que no comprueba la longitud de la cadena y devuelve \textit{true} si es 0. Sino que devuelve \textit{true} si la longitud es 0, o si no es 0 pero todos los caracteres de la cadena son espacios en blanco.
%	\item De la clase \textit{java.util.Optional} \footnote{\url{https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Optional.html}}, soportada desde la versión 1.8, se utiliza la función \textit{orElseThrow()}, que se soporta desde la versión 10, por tanto habría que buscar una alternativa para pasar a la versión 1.8. La versión 11 trae a esta clase la función \textit{isEmpty()}.
%\end{itemize}
%
%Para saber más sobre las novedades de Java 11 es recomendable leer `\textit{JDK 11 Release Notes}' \cite{oracle_jdk_nodate}. También hay un artículo que explica las principales diferencias entre Java 8 y Java 11 llamado `\textit{De Java 8 a Java 11, ¿aún no te has migrado?}' \cite{del_hoyo_java_2019}.

\subsubsection{Trabajo con streams de Java}

Los \textit{Streams}, presentes en Java desde la versión Java 1.8 son muy útiles ya que facilitan enormemente el procesamiento de grandes colecciones de datos. Estos permiten, usando un predicado, \textbf{filtrar} datos de una colección, \textbf{ordenar} los datos mediante un comparador, \textbf{mapear} o \textbf{reducir} los datos mediante alguna función y \textbf{almacenarlos} en algún tipo de colección mediante un colector. \\ 
Destacan dos funcionalidades, el \textit{mapeo} que asocia cada dato del stream con un nuevo elemento (como el cálculo del cuadrado de cada elemento) y la \textit{reducción} que permite obtener un único resultado a partir del conjunto de datos (como la suma de un conjunto de datos).

Un ejemplo de uso de \textit{streams} en la aplicación:\\
\begin{minipage}{\linewidth}
{\tiny
\begin{verbatim}
...
List<CustomGitlabApiRelease> repositoryReleases = repository.getRepositoryInternalMetrics().getReleases()
					.stream().collect(Collectors.toList());
...
List<CustomGithubApiRelease> repositoryReleases = repository.getRepositoryInternalMetrics().getGHReleases()
					.stream().collect(Collectors.toList());
...
\end{verbatim}
}
\end{minipage}

En el ejemplo se obtienen tanto de la API de GitLab como de la de GitHub un \textit{stream} con las \textit{releases} de un proyecto y se recogen los resultados en una lista (\textit{collect}).


\subsubsection{Interfaces funcionales y funciones lambda de Java}

EN el proyecto también se hace uso de interfaces funcionales y funciones lambda. En la sección anterior ya vemos el uso de dos funciones lambda en el código mostrado (argumentos de las funciones \textit{filter} y \textit{map}).

El paquete \textit{java.util.function} \footnote{\url{https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html}} es soportado por Java desde la versión 1.8. Este paquete permite almacenar funciones en variables. 
\\Las funciones lambda son funciones anónimas con sintaxis \\
\begin{minipage}{\linewidth}
{\tiny
\begin{verbatim}
(parametros) -> {cuerpo funcion lambda}
\end{verbatim}
}
\end{minipage}
que no están declaradas en una clase y pueden ser utilizadas en cualquier parte, pasarse como parámetro a una función y ser almacenadas en variables.
\\Las interfaces funcionales \footnote{\url{https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html}} son interfaces con un único método, que es abstracto, llamado método funcional. Este método permite restringir los tipos de los parámetros y de los valores de retorno de una función lambda.

Estas han sido utilizadas en numerosas ocasiones tanto para los \textit{streams} (como se observa en el código anterior), como en elementos de la interfaz gráfica y otros elementos sensibles a eventos como por ejemplo:\\

\begin{minipage}{\linewidth}
{\tiny
\begin{verbatim}
...
this.button.addClickListener(event -> addRepository(repositorySourceType));
...
this.closeButton.addClickListener(event -> fireEvent(new CloseEvent(this)));
...
\end{verbatim}
}
\end{minipage}

También han sido utilizadas para almacenar funciones en variables, definiendo una interfaz funcional para restringir los tipos parámetros y de los resultados de la función. Un aspecto importante es que las variables que almacenen funciones NO se pueden serializar, por eso la variable \textit{EVAL\_FUNC\_GREATER\_THAN\_Q1} del código siguiente se ha marcado como \textit{transient} dentro de una clase que implementa \textit{Serializable}.

\begin{minipage}{\linewidth}
{\tiny
\begin{verbatim}
...
public interface Metric extends Serializable {
 @FunctionalInterface
 public interface EvaluationFunction {
   EvaluationResult evaluate(IValue value, IValue minValue, IValue maxValue);
 }

 ...
 
 EvaluationResult evaluate(IValue measuredValue);

 EvaluationFunction getEvaluationFunction();
}

...
public abstract class NumericValueMetricTemplate implements Metric {
  ...
  protected transient static final EvaluationFunction EVAL_FUNC_GREATER_THAN_Q1 = 
    (measuredValue, minValue, maxValue) -> 
     {
      try {
        Double value, min;
	    value = ...
	    min = ...
	    if (value > min) return EvaluationResult.GOOD;
	    else if (value.equals(min)) return EvaluationResult.WARNING;
	    else return EvaluationResult.BAD;
	  } catch (Exception e){
	    return EvaluationResult.BAD;
	  }
    };
  ...
}
...
\end{verbatim}
}
\end{minipage}

En el ejemplo anterior muestra la manera en la que las métricas podrían valorarse. La métrica será dada como buena si supera el umbral inferior. Cada métrica podrá usar esta función o implementar una función propia si es necesaria una mayor particularización. Los requisitos definidos en la interfaz funcional son que esa función deberá tener tres argumentos del tipo \textit{IValue} y devolver un resultado del tipo \textit{EvaluationResult}.


Además, para poder serializar los resultados obtenidos en las nuevas métricas relacionadas con los \textit{jobs} y las \textit{releases}, ha sido necesario emplear clases propias que sí son serializables ya que las que vienen con las integraciones no lo son. Podemos verlo en los siguientes ejemplos de código:

\begin{minipage}{\linewidth}
{\tiny
\begin{verbatim}
...
public class CustomGithubApiJob implements Serializable {
	private static final long serialVersionUID = -7602110263950506090L;
	
	private transient GHWorkflowJob job;
	
	/**
	 * Store as variables in this class the ones of Job used to calculate metrics, use these instead of the Job ones to calculations.
	 * This is needed because during the imports the Job is set to null.
	 */
	private String name;
	
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public CustomGithubApiJob(GHWorkflowJob job) {
		super();
		this.job = job;
		this.name = job.getName();
	}

	public GHWorkflowJob getJob() {
		return job;
	}

	public void setJob(GHWorkflowJob job) {
		this.job = job;
	}
}

...

public class CustomGitlabApiRelease implements Serializable  {
	private static final long serialVersionUID = -5602110263950506090L;

	private transient Release release;

	public CustomGitlabApiRelease(Release release) {
		super();
		this.release = release;
	}

	public Release getRelease() {
		return release;
	}

	public void setRelease(Release release) {
		this.release = release;
	}
}


...
\end{verbatim}
}
\end{minipage}

Como podemos ver también hacemos uso de \textit{transient} para poder realizar la serialización.

\subsection{Maven}

Maven es una herramienta de gestión de proyectos software. Esta herramienta facilita, a partir de un único fichero con extensión \textit{XML} llamado \ruta{pom.xml} \footnote{Project Object Model}:
\begin{itemize}
	\tightlist
	\item La construcción y compilación del proyecto.
	\item La generación de documentación.
	\item La generación de informes.
	\item La gestión de las dependencias del proyecto.
	\item La integración con un sistema de control de versiones como Git, y el trabajo con repositorios remotos como GitLab o GitHub e incluso en repositorios \textit{self-hosted} \footnote{Repositorios almacenados en servidores gestionados por la propia empresa o equipo que desarrolla el software}.
	\item La generación y distribución de \textit{releases}.
\end{itemize}
Maven puede crear la estructura de directorios del proyecto, administrar las dependencias y descargar las librerías necesarias. Además, es compatible con la mayoría de IDEs \footnote{Integrated Development Environment - Entorno de desarrollo integrado}. Por ejemplo, en este proyecto se ha trabajado sobre Eclipse IDE, el cual tiene muy buena integración con Maven, como se puede observar en la Fig. \ref{fig:M5_Eclipse_Maven}.

\imagen{M5_Eclipse_Maven}{Integración de Maven con Eclipse}

También permite el uso de arquetipos, que son patrones o plantillas que se aplican en la infraestructura del proyecto.

Aunque puede resultar difícil configurar correctamente Maven a través del archivo de configuración, debido sobre todo al buen número de herramientas a configurar en él, una vez configurado, nos ahorra mucho tiempo y nos permite centrarnos en el desarrollo de funcionalidad.

\subsection{Sistema de control de versiones}

Se ha utilizado Git para el desarrollo del proyecto para el control de versiones y se ha utilizado GitHub como repositorio remoto. 

GitHub no sólo ha permitido el almacenamiento del código del proyecto si no que también ha permitido el seguimiento y colaboración alumno-tutor gracias a las herramientas que proporciona. Además, utilizando ZenHub (que se puede integrar en el propio GitHub) se ha llevado a cabo la gestión de las tareas (\textit{issues}) del proyecto. Como se puede observar en la siguiente figura:

\imagen{M5_GitHub-ZenHub_board}{Tablero de Scrum en ZenHub integrado en GitHub}

Es posible configurar Eclipse y Maven para trabajar con Git. Sin embargo, debido a la costumbre de uso directamente en consola del alumno, se ha optado por el uso de GitBash tal y como se muestra en la Fig. \ref{fig:M5_GitBash}.

\imagen{M5_GitBash}{Consola para Git de Windows GitBash}

\subsection{Logger}


Un \textit{logger} permite crear mensajes para el seguimiento o registro de la ejecución de una aplicación. Puede resultar de utilidad, por ejemplo, para realizar la depuración de la aplicación si se muestran los distintos puntos o estados por lo que va pasando la ejecución con los valores tomados por variables de interés\cite{logger_info}.

Este tipo de mensajes se pueden obtener también con la instrucción System.out.println() para mostrar mensajes en la salida estándar, pero esta clase Logger ofrece la ventaja de poder emitir la salida también en archivos con diferentes formatos (XML, TXT, HTML, etc).

El uso de un \textit{logger} se puede utilizar en cualquier entorno, en desarrollo, se utiliza para mostrar los mensajes por consola y ayudar a los desarrolladores a detectar y solucionar problemas de forma rápida. En cambio, en entornos de producción se almacenan los logs capturados en una base de datos para que puedan ser analizados de forma centralizada y se puedan analizar los logs provenientes de los diferentes usuarios finales de la aplicación.


Cada mensaje generado con la clase Logger debe tener asignado un nivel de importancia. Por ejemplo, se podrían plantear los siguientes niveles ordenador de mayor importancia a menos\cite{Level_class_info}:
\begin{description}
\item \textbf{SEVERE}: Nivel de mensaje indicando un error crítico.
\item \textbf{WARNING}: Indica un error potencial.
\item \textbf{INFO}: Para mensajes informativos.
\item \textbf{CONFIG}: Usado con mensajes relacionados con la configuración.
\item \textbf{FINE}: Proporciona información de traza de la ejecución.
\item \textbf{FINER}: Proporciona información de traza de la ejecución más detallada.
\item \textbf{FINEST}: Proporciona información de traza de la ejecución muy detallada.

La clase Level de Java nos permite usar estos niveles y usándola podemos establecer a partir de qué nivel se deben almacenar o mostrar los mensajes de log.

\end{description}

Se han mantenido las herramientas utilizadas en la primera iteración del proyecto \cite{TFGPrevio} actualizando a versiones actuales para evitar vulnerabilidades:
\begin{itemize}
	\item \textbf{SLF4J} (\textit{Simple Logging Facade for Java}): proporciona una API de registro Java a través de un simple patrón de fachada. El servidor de registro subyacente se determina en tiempo de implementación y puede ser java.util.logging , log4j, logback o tinylog. La separación de la API de cliente desde el servidor de registro reduce el acoplamiento entre una aplicación y cualquier marco de registro especial. Esto puede hacer más fácil integrar con código existente o de terceros o entregar código en otros proyectos que ya han hecho una opción de registro de back-end\cite{SLF4J_wiki}.

	\item\textbf{Log4j}: es una biblioteca de código abierto desarrollada en Java por la Apache Software Foundation que permite a los desarrolladores de software escribir mensajes de registro, cuyo propósito es dejar constancia de una determinada transacción en tiempo de ejecución. Log4j permite filtrar los mensajes en función de su importancia. La configuración de salida y granularidad de los mensajes es realizada en tiempo de ejecución mediante el uso de archivos de configuración externos \cite{Log4j_wiki}. 
	\\A través del fichero \textit{log4j2} con extensión \textit{XML}, \textit{JSON}, \textit{YAML} o \textit{Properties} se pueden configurar diferentes aspectos como los niveles y el formato de los mensajes\footnote{Manual de configuración de Log4j 2: \url{https://logging.apache.org/log4j/2.x/manual/configuration.html}} \cite{apache_apache_nodate}. 
	\\En este proyecto se configuró mediante un fichero con extensión \textit{.properties}, localizado en la carpeta \textit{resources} \ruta{src/main/resources} para que los mensajes sean redirigidos a un fichero con ruta \textit{log/log4.log}. También se muestran por consola si estamos en el entorno de desarrollo.	
\end{itemize}

Como las dos herramientas tienen integración con Maven sólo es necesario añadir en el fichero \ruta{pom.xml} las dependencias correspondientes en el fichero \ruta{pom.xml} del proyecto


Para poder añadir mensajes con el \textit{logger}, utilizamos la API SLF4J (\ruta{slf4j-api}). Eso permite que si cambiáramos de Log4J a otro \textit{logger} no tuviéramos que modificar el código si no sólo la conexión con la API SLF4J.

Para ello, en primer lugar, se debe obtener en cada clase que quiera ser utilizado:\\
\begin{minipage}{\linewidth}
{\tiny
\begin{verbatim}
private static final Logger LOGGER = LoggerFactory.getLogger(MetricsService.class);
\end{verbatim}
}
\end{minipage}
en segundo lugar, para añadir un mensaje sólo es necesario realizar una llamada al \textit{logger} estableciendo el nivel de error:\\
\begin{minipage}{\linewidth}
{\tiny
\begin{verbatim}
LOGGER.error("Error fetching a repository. Message: " + e.getMessage());
\end{verbatim}
}
\end{minipage}


\section{Automatización del proceso de desarrollo}

La automatización del flujo de trabajo ha permitido el despliegue continuo de la aplicación, para ello se ha trabajado con las herramientas que ofrece GitHub y que vamos a ver a continuación.

\subsection{CI/CD: GitHub Actions}

Se ha utilizado el sistema de despliegue e integración continua (CICD) que ofrece GitHub, \textit{\textbf{GitHub Actions}}, que permiten configurar CICD para una gran cantidad de tipos de proyectos incluyendo proyectos Java que utilicen Maven como es el caso del presente proyecto. En la siguiente figura podemos ver algunos de los \textit{actions} que existen para Java:

\begin{figure}[!h]
	\centering
	\includegraphics[width=0.7\textwidth]{M5_Java_GitHub_Actions}
	\caption{Algunos de los GitHub Actions existentes para Java}\label{fig:M5_Java_GitHub_Actions}
\end{figure}
\FloatBarrier


Las \textit{GitHub actions} son procesos (también denominados \textit{jobs}) que se ejecutan cuando nuevo código es subido al repositorio remoto, por ejemplo a través de un \textit{commit} o un \textit{merge} de una rama de desarrollo de una funcionalidad concreta. Además, cabe destacar que se agrupan en los llamados \textit{workflows}.
En el caso de este proyecto se ha configurado un \textit{workflow} para que se ejecuten una serie de \textit{jobs} o tareas cuando se suba nuevo código a la rama \textit{main} del mismo.

Se han configurado 4 etapas:
\begin{itemize}
	\item \textbf{Compilación} (\textit{build}). Se ejecuta el \textit{build} del proyecto con Maven. Que  ejecute correctamente es necesario para continuar.
	\item \textbf{Pruebas} (\textit{test}). Se ejecutan las pruebas unitarias definidas en el proyecto y se comprueba que estas pasen.
	\item \textbf{Despliegue} (\textit{deployment}). Se despliega la aplicación en producción en \textbf{Heroku}.Para ello se realizan dos tareas, en primer lugar se hace login con el usuario de \textit{Heroku} del proyecto y en segundo lugar se sube el .war obtenido en el paso de compilación.\\
	
	 La url de la aplicación desplegada es:\\
	\url{https://evolution-metrics-v2.herokuapp.com/}
\end{itemize}

El \textit{workflow} configurado para el proyecto se ha denominado \textit{build-and-deploy} y en la siguiente figura podemos ver los diferentes pasos que se ejecutan en el mismo:

\begin{figure}[!h]
	\centering
	\includegraphics[width=0.7\textwidth]{M5_GitHub_workflow}
	\caption{\textit{Workflow} definido para el proyecto}\label{fig:M5_GitHub_workflow}
\end{figure}
\FloatBarrier

La definición del \textit{workflow} se realiza en el archivo /.github/workflows/maven.yml y cuyo contenido es el siguiente:
\begin{minipage}{\linewidth}
{\tiny
\begin{verbatim}
...
# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-maven

name: Java CI with Maven

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up JDK 11
      uses: actions/setup-java@v3
      with:
        java-version: '11'
        distribution: 'temurin'
        cache: maven
    - name: Build with Maven
      run: mvn -B package -Pproduction --file pom.xml
 
    - name: Run tests
      run: | 
        mvn clean jacoco:prepare-agent install jacoco:report
        
    - name: Login to Heroku
      uses: akhileshns/heroku-deploy@v3.12.12
      with:
        heroku_api_key: ${{secrets.HEROKU_API_KEY}}
        heroku_app_name: "evolution-metrics-v2"
        heroku_email: "jgm1009@alu.ubu.es"
        justlogin: true
        
    - name: Deploy to Heroku
      run: |
       heroku plugins:install heroku-cli-deploy
       heroku war:deploy target/evolution-metrics-gauge-v2-2.0.0.war --app evolution-metrics-v2
...
\end{verbatim}
}
\end{minipage}


\subsubsection{Tokens y variables necesarias}
Para poder ejecutar las \textit{actions} definidas ha sido necesario almacenar el \textit{API key} de \textit{Heroku}, el cual nos permite hacer login y posteriormente realizar el despliegue. En el código de la configuración anterior se ha podido ver que las variables se llaman de la siguiente manera: 

\begin{minipage}{\linewidth}
{\tiny
\begin{verbatim}
...
     heroku_api_key: ${{secrets.HEROKU_API_KEY}}
...
\end{verbatim}
}
\end{minipage}

Podemos ver en la siguiente figura cómo se almacenan los denominados \textit{secrets} en GitHub:

\begin{figure}[!h]
	\centering
	\includegraphics[width=0.7\textwidth]{M5_Action_secrets}
	\caption{\textit{Secrets} o variables definidas para el proyecto en GitHub}\label{fig:M5_Action_secrets}
\end{figure}
\FloatBarrier

\subsubsection{Badges}
Los denominados \textit{badges} son pequeños distintivos que se añaden en el archivo readme.md del proyecto para dar más visibilidad a cierta información relevante.
En el proyecto se han incluido dos \textit{badges} para representar el estado del despliegue continuo (\textit{pipeline}) que refleja el estado de la última ejecución del \textit{workflow} previamente explicado. También se ha incluido una \textit{badge} para indicar si la aplicación está desplegada o no en Heroku.

Podemos verlas en la siguiente figura:

\begin{figure}[!h]
	\centering
	\includegraphics[width=0.7\textwidth]{M5_Badges}
	\caption{\textit{Badges} en el Readme.md del proyecto}\label{fig:M5_Badges}
\end{figure}
\FloatBarrier

Y el código de las mismas es:\\

\begin{minipage}{\linewidth}
{\tiny
\begin{verbatim}
...
![build-and-deploy](https://github.com/Joaquin-GM/GII_O_MA_19.07-Comparador-de-metricas-de-evolucion-en-repositorios-Software/actions/workflows/maven.yml/badge.svg)
[![Heroku](http://heroku-badge.herokuapp.com/?app=evolution-metrics-v2&style=flat&svg=1)](https://evolution-metrics-v2.herokuapp.com/)
...
\end{verbatim}
}
\end{minipage}

\subsection{Revisión automática de la cobertura}

La cobertura es el porcentaje de la aplicación que está probado por algún test. Esta cobertura se puede medir en relación al total de lineas de código, al número de instrucciones, clases o al número de bifurcaciones en condicionales y bucles o bien a número de métodos.

Para realizar las revisiones automáticas de cobertura, lo primero que hay que hacer es definir las pruebas utilizando JUnit y ejecutarlas y posteriormente, utilizando JaCoCo generaremos un informe donde se nos muestran los valores de cobertura del código.

Podemos ver un ejemplo de informe generado con JaCoCo en la siguiente figura:

\begin{figure}[!h]
	\centering
	\includegraphics[width=0.7\textwidth]{M5_JaCoCo_report }
	\caption{Ejemplo de informe generado por JaCoCo}\label{fig:M5_JaCoCo_report}
\end{figure}
\FloatBarrier


\subsubsection{Configuración de JaCoCo con Maven}

Para poder utilizar JaCoco, tenemos que establecer varios valores de configuración en el archivo pom.xml. En primer lugar, debemos establecer la carpeta donde alojar los informes generados:\\
\begin{minipage}{\linewidth}
{\tiny
\begin{verbatim}
...
<reporting>
  <outputDirectory>${project.build.directory}/reports</outputDirectory>
</reporting>
...
\end{verbatim}
}
\end{minipage}

Tras esto tenemos que añadir el plugin de la siguiente de JaCoCo para Maven:\\
\begin{minipage}{\linewidth}
{\tiny
\begin{verbatim}
...
<plugin>
  <groupId>org.jacoco</groupId>
  <artifactId>jacoco-maven-plugin</artifactId>
  <version>0.8.3</version>
  <configuration>
	<outputDirectory>${project.reporting.outputDirectory}/jacoco-reports</outputDirectory>
	<output>file</output>
	<title>Coverage of project: ${project.name}</title>
  </configuration>
</plugin>
...
\end{verbatim}
}
\end{minipage}
En la configuración se define:
\begin{itemize}
	\tightlist
	\item El directorio de destino de los informes
	\item Que se desea que se generen en forma de fichero
	\item El título del fichero
\end{itemize}
 Una vez tenemos la configuración establecida, para generar los informes con Maven tenemos que ejecutar:
 
\begin{minipage}{\linewidth}
{\tiny
\begin{verbatim}
$ mvn clean jacoco:prepare-agent install jacoco:report
$ mvn jacoco:report
\end{verbatim}
}
\end{minipage}

El primer comando genera el fichero \ruta{jacoco.exec} que es necesario para la ejecución del segundo comando.


\section{Diseño extensible}
Anteriormente en la sección \ref{sect:3_3_3_FrameworkMedicion} - `Framework de medición' se ha visto cómo en el proyecto se implementa un framework de medición que permite la reutilización en el cálculo de métricas esto ha permitido implementar las cinco nuevas métricas relacionadas con CICD y realizar la nueva integración con GitHub.

El paquete \textit{repositorydatasource}, en el que previamente se realizaba sólo la conexión con GitLab, se ha extendido de forma que ahora también incluye la integración con GitHub. Esto se ha conseguido aplicando el patrón de diseño: método fábrica y diferenciando entre las dos forjas de repositorios tenemos las clases: \textit{RepositoryDataSourceUsingGithubAPI}, \textit{RepositoryDataSourceFactoryGithub}, \textit{RepositoryDataSourceUsingGitlabAPI} y \textit{RepositoryDataSourceFactoryGitlab} que implementan las interfaces \textit{RepositoryDataSource} y \textit{RepositoryDataSourceFactory}. Utilizando este mismo diseño e implementando las interfaces anteriores en nuevas clases se puede seguir extendiendo la funcionalidad del a aplicación a otras forjas de repositorios en un futuro.

De la misma manera, en la interfaz gráfica se han realizado las modificaciones necesarias para realizar la conexión de manera diferenciada e independiente con GitHub y con GitLab y para poder añadir repositorios alojados en cada una de ellas. Podemos ver las nuevas características de la interfaz en las siguientes figuras:

\begin{figure}[!h]
	\centering
	\includegraphics[width=0.7\textwidth]{M5_GitHub_connection }
	\caption{Conexión con GitHub.}\label{fig:M5_GitHub_connection}
\end{figure}
\FloatBarrier

\begin{figure}[!h]
	\centering
	\includegraphics[width=0.7\textwidth]{M5_GitLab_connection }
	\caption{Conexión con GitLab.}\label{fig:M5_GitLab_connection}
\end{figure}
\FloatBarrier

\begin{figure}[!h]
	\centering
	\includegraphics[width=0.7\textwidth]{M5_Add_repository }
	\caption{Desplegable con opciones para añadir repositorios.}\label{fig:M5_Add_repository}
\end{figure}
\FloatBarrier

\begin{figure}[!h]
	\centering
	\includegraphics[width=1\textwidth]{M5_Both_Connections }
	\caption{Interfaz de la aplicación donde se pueden ver las dos conexiones independientes a las dos forjas.}\label{fig:M5_Both_Connections}
\end{figure}
\FloatBarrier

Para implementar la nueva forma de añadir repositorios de GitHub se reutiliza la clase \textit{AddRepositoryFormTemplate} ya utilizada para GitLab y la clase \textit{AddRepositoryDialog} con la función:\\

\begin{minipage}{\linewidth}
{\tiny
\begin{verbatim}
...
private void createConnectionForms() {
  addRepositoryForms.add(new AddRepositoryFormByUsername());
  addRepositoryForms.add(new AddRepositoryFormByGroup());
  addRepositoryForms.add(new AddRepositoryFormByURL());
}
...
\end{verbatim}
}
\end{minipage}

\newpage
Para implementar la nueva formas de conexión (y las posibles futuras que se podrían añadir) se ha incrementado la funcionalidad del método \textit{createConnectionForms} de la clase \textit{ConnectionDialog}:\\

\begin{minipage}{\linewidth}
{\tiny
\begin{verbatim}
...
	private void createConnectionForms() {
		if (repositorySourceType.equals(RepositorySourceType.GitLab)) {
			ConnectionForm userPasswordConnForm = new ConnectionFormUsingUserPassword(repositorySourceType);
			connectionForms.add(userPasswordConnForm);

			ConnectionForm paTokenConnForm = new ConnectionFormUsingPAToken(repositorySourceType);
			connectionForms.add(paTokenConnForm);

			ConnectionForm publicConnForm = new ConnectionFormUsingPublicConn(repositorySourceType);
			connectionForms.add(publicConnForm);

			ConnectionForm noConnForm = new ConnectionFormWithoutConn(repositorySourceType);
			connectionForms.add(noConnForm);
			
		} else if (repositorySourceType.equals(RepositorySourceType.GitHub)) {
			// Conection with username and password deprecated for GitHub, public connection also not allowed
			ConnectionForm paTokenConnForm = new ConnectionFormUsingPAToken(repositorySourceType);
			connectionForms.add(paTokenConnForm);

			ConnectionForm noConnForm = new ConnectionFormWithoutConn(repositorySourceType);
			connectionForms.add(noConnForm);
		}
	
	}
...
\end{verbatim}
}
\end{minipage}

Cabe destacar como se ve en el código anterior que dependiendo de la forja se permiten diferentes tipos de conexión. GitHub sólo permite trabajar con su API utilizando un token privado mientras que GitLab si permite también el uso de una conexión pública (aunque con funcionalidad restringida, por ejemplo, no permite calcular las métricas relacionadas con CICD pues no se pueden recuperar datos de \textit{jobs} y de \textit{releases} con este tipo de conexión).\\
Además, cabe indicar que GitHub no permite la conexión vía usuario y contraseña pues está \textit{deprecada}, ver:\\
\url{https://docs.github.com/es/rest/overview/other-authentication-methods}

\newpage
\section{API de GitHub} 

GitHub ofrece una API \footnote{\url{https://docs.gitlab.com/ee/api/}} REST \footnote{Representational state transfer} para poder acceder a la información e interactuar con los repositorios alojados en GitHub. Para interactuar con esta API se ha utilizado la librería:\\

\textit{gitlab4j/gitlab4j-api} \footnote{\url{https://github.com/gitlab4j/gitlab4j-api}}\\
Para poder utilizarla en el proyecto se ha incluido en el archivo pom.xml como plugin de Maven de la siguiente manera:

\begin{minipage}{\linewidth}
{\tiny
\begin{verbatim}
...
	<dependencies>
	 ...
		<!-- Github API alternative updated 2022 -->
		<!-- https://mvnrepository.com/artifact/org.kohsuke/github-api -->
		<dependency>
			<groupId>org.kohsuke</groupId>
			<artifactId>github-api</artifactId>
			<version>1.306</version>
		</dependency>
	 ...
	/<dependencies>
...
\end{verbatim}
}
\end{minipage}\\

\newpage
Algunos ejemplos de usos de la librería en la aplicación:

\begin{minipage}{\linewidth}
{\tiny
\begin{verbatim}
...
private GitHub githubclientApi;

...

public void connect(RepositorySourceType repositorySourceType) throws RepositoryDataSourceException {
		if (connectionType.equals(EnumConnectionType.NOT_CONNECTED)) {
			// githubclientApi = new GitHubClient();
			try {
				githubclientApi = GitHub.connect();
				currentUser = null;
				connectionType = EnumConnectionType.CONNECTED;
				LOGGER.info("Established connection with GitHub public way");

			} catch (IOException e) {
				LOGGER.error("Error connecting to GitHub: " + e.toString());
			}

		} else {
			throw new RepositoryDataSourceException(RepositoryDataSourceException.ALREADY_CONNECTED);
		}

}

...

public Collection<datamodel.Repository> getCurrentUserRepositories
(RepositorySourceType repositorySourceType)	throws RepositoryDataSourceException {

		try {
			Collection<datamodel.Repository> resultrepositories = new ArrayList<datamodel.Repository>();
			if (connectionType != EnumConnectionType.NOT_CONNECTED) {
				List<GHRepository> lRepositories = githubclientApi.searchRepositories().
				  user(currentUser.getName()).list().toList();

				for (GHRepository repo : lRepositories) {
					mapUrlIdRepo.put(repo.getId(), repo);
					resultrepositories.add(
					  new datamodel.Repository(
					    repo.getHtmlUrl().toString(), repo.getName(), repo.getId(
					  )
					);
				}
				return resultrepositories;
			} else {
				throw new RepositoryDataSourceException(RepositoryDataSourceException.NOT_CONNECTED);
			}
		} catch (IOException e) {
			throw new RepositoryDataSourceException(RepositoryDataSourceException.REPOSITORY_NOT_FOUND);
		}
}

...
\end{verbatim}
}
\end{minipage}\\

\newpage
\section{API de GitLab}

De la misma manera, GitLab ofrece una API \footnote{\url{https://docs.gitlab.com/ee/api/}} REST \footnote{Representational state transfer} para poder acceder a la información e interactuar con los repositorios alojados en GitLab. Para interactuar con esta API se ha utilizado la librería:\\

\textit{gitlab4j/gitlab4j-api} \footnote{\url{https://github.com/gitlab4j/gitlab4j-api}}\\

Para poder utilizarla en el proyecto se ha incluido en el archivo pom.xml como plugin de Maven de la siguiente manera:\\

\begin{minipage}{\linewidth}
{\tiny
\begin{verbatim}
...
	<dependencies>
	 ...
		<!-- GitLab API -->
		<!-- https://mvnrepository.com/artifact/org.gitlab4j/gitlab4j-api -->
		<dependency>
			<groupId>org.gitlab4j</groupId>
			<artifactId>gitlab4j-api</artifactId>
			<version>5.0.1</version>
			<scope>compile</scope>
		</dependency>
	 ...
	/<dependencies>
...
\end{verbatim}
}
\end{minipage}

\newpage

Algunos ejemplos de usos de la librería en la aplicación:\\

\begin{minipage}{\linewidth}
{\tiny
\begin{verbatim}
...
private GitLabApi gitLabApi;

...

public void connect(String username, String password, RepositorySourceType repositorySourceType)
			throws RepositoryDataSourceException {
		try {
			if (username == null || password == null || username.isBlank() || password.isBlank())
				throw new RepositoryDataSourceException(RepositoryDataSourceException.LOGIN_ERROR);
			if (connectionType.equals(EnumConnectionType.NOT_CONNECTED)) {
				gitLabApi = GitLabApi.oauth2Login(RepositoryDataSourceUsingGitlabAPI.HOST_URL, username,
						password.toCharArray());
				currentUser = getCurrentUser(gitLabApi.getUserApi().getCurrentUser());
				connectionType = EnumConnectionType.LOGGED;
				LOGGER.info("Logged to GitLab");
			} else {
				throw new RepositoryDataSourceException(RepositoryDataSourceException.ALREADY_CONNECTED);
			}
		} catch (GitLabApiException e) {
			reset();
			throw new RepositoryDataSourceException(RepositoryDataSourceException.LOGIN_ERROR);
		} catch (Exception e) {
			throw e;
		}
	}

...

public Collection<Repository> getAllUserRepositories(String userIdOrUsername,
			RepositorySourceType repositorySourceType) throws RepositoryDataSourceException {
		Collection<Repository> repositories;
		try {
			if (currentUser != null && currentUser.getUsername().equals(userIdOrUsername)) {
				repositories = getCurrentUserRepositories(repositorySourceType);
			} else if (!connectionType.equals(EnumConnectionType.NOT_CONNECTED)) {
				repositories = gitLabApi.getProjectApi().getUserProjectsStream(userIdOrUsername, new ProjectFilter())
						.map(p -> new Repository(p.getWebUrl(), p.getName(), p.getId())).collect(Collectors.toList());
			} else {
				throw new RepositoryDataSourceException(RepositoryDataSourceException.NOT_CONNECTED);
			}
			return repositories;
		} catch (RepositoryDataSourceException e) {
			throw e;
		} catch (GitLabApiException e) {
			throw new RepositoryDataSourceException(RepositoryDataSourceException.USER_NOT_FOUND);
		}
	}
	
...
\end{verbatim}
}
\end{minipage}

\section{Interfaz gráfica: Vaadin}

